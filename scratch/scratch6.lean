    import algebra.group_power
     
    variables {α : Type} [group α] (a b g : α)
    def comm := a*b*a⁻¹*b⁻¹
    def conj := a*b*a⁻¹
     
    local notation `[[`a, b`]]` := comm a b
     
     
    lemma commuting : [[a, b]] = 1 ↔ a*b = b*a :=
    by simp [comm, mul_inv_eq_iff_eq_mul]
     
    /-
    begin
    unfold comm,
    split,
    intro hyp, simpa using congr_arg (λ x, x * b * a) hyp,
    intro hyp, simpa using congr_arg (λ x, x * a⁻¹ * b⁻¹) hyp,
    end
    -/
     
    local attribute [simp] mul_assoc
     
    lemma inv_conj : (b*a*b⁻¹)⁻¹ = b*a⁻¹*b⁻¹ := by simp
     
    lemma commutator_trading : [[g⁻¹*a*g, b]] = 1 →
    ∃ c d e f : α, [[a, b]] = (conj c g)*(conj d g⁻¹)*(conj e g)*(conj f g⁻¹) :=
    begin
    let a':= g⁻¹*a*g,
     
    -- Following two lines replaces the premise by an equivalent one, is there a 1 line equivalent?
    intro comm_hyp,
    rw commuting at comm_hyp,
     
    have H : a = g*a'*g⁻¹, by {dsimp [a'], simp},
     
    have := calc
    [[a, b]] = a * b * a⁻¹ * b⁻¹ : by { refl }
    ... = (g * a' * g⁻¹) * b * (g * a'⁻¹ * g⁻¹) * b⁻¹ : by { repeat {rw H}; simp}
    ... = g * a' * g⁻¹ * (a'⁻¹ * a') * b * g * a'⁻¹ * (b⁻¹ * b) * g⁻¹* b⁻¹ : by {simp}
    ... = g * a' * g⁻¹ * a'⁻¹ * b * a' * g * a'⁻¹ * b⁻¹ * b * g⁻¹* b⁻¹ : by {simp [comm_hyp]}
    ... = (conj 1 g) * (conj a' g⁻¹) * (conj (b*a') g) * (conj b g⁻¹) : by { repeat {rw conj}, dsimp [a'], simp},
     
    existsi [(1: α), a', (b*a'), b],
    assumption,
    end
     
     
    def is_invariant_norm (ν : α → ℕ) :=
    (∀ g : α, ν g ≥ 0) ∧ -- this is silly but ultimately the target will be ℝ
    (∀ g : α, ν g = 0 → g = 1) ∧
    (∀ g h : α, ν (g*h) ≤ ν g + ν h) ∧
    (∀ g : α, ν g = ν g⁻¹) ∧
    (∀ g h : α, ν g = ν (h*g*h⁻¹))
     
    def is_invariant_set (S : set α) :=
    (∀ g s : α, s ∈ S → conj g s ∈ S) ∧
    (∀ s : α, s ∈ S → s⁻¹ ∈ S)
     
    noncomputable theory
    local attribute [instance] classical.prop_decidable
     
    /- "is_in_ball S n a" means a belongs to the radius n ball around 1 for
       the norm associated to S on the subgroup generated by S. It can happen
       for three inductive reasons -/
    inductive is_in_ball (S : set α) : ℕ → α → Prop
    | zero : is_in_ball 0 1
    | succ_plus (a ∈ S) {b n} : is_in_ball n b → is_in_ball (n+1) (a * b)
    | succ_minus (a ∈ S) {b n} : is_in_ball n b → is_in_ball (n+1) (a⁻¹ * b)
     
    def is_generating (S) := ∀ a : α, ∃ n, is_in_ball S n a
     
    /- the norm associated to a generating set S. Maybe not invariant if S isn't -/
    def gen_norm (S : set α) (h : is_generating S) (a : α) := nat.find (h a)
     
    lemma norm_min (S : set α) (h : is_generating S) (a) (n) :
    is_in_ball S n a → gen_norm S h a  ≤ n :=
    begin
    intro,
    apply nat.find_min',
    assumption
    end

     lemma ball_zero_iff_id (S : set α) : is_in_ball S 0 a ↔ a = 1 :=
    begin
    split,
    { intro H,
      cases H,
      refl,
    },
    intro H,rw [H], 
    exact is_in_ball.zero S,
    end 

   lemma norm_min' (S : set α) (h : is_generating S) (a) (n) :
    is_in_ball S n a ↔ gen_norm S h a ≤ n :=
    begin
    split,
    { intro,
      apply nat.find_min',
      assumption },
    induction n with d Hd,
--    apply nat.find_min,
    { --rw ball_zero_iff_id,
      intro H,
      show is_in_ball S 0 a,
      have H1 : gen_norm S h a = 0 := nat.eq_zero_of_le_zero H,
      clear H,
      have H2 : nat.find (h a) = 0 := H1,
      show is_in_ball S 0 a,
      rw [←H1],
      --unfold is_in_ball,
      exact @nat.find_spec
    },
    admit
    end

#check @nat.find_spec    


lemma main : false :=
begin
have helper : (∃ x : ℕ, true) → false :=
    λ ⟨x, h⟩, by apply _fun_match; assumption,
exact helper ⟨0, ⟨⟩⟩
end

#check main 



     
    lemma inv_norm_of_inv_set (S : set α) (h : is_generating S) :
    is_invariant_set S → is_invariant_norm (gen_norm S h) :=
    begin
    intro inv_hyp,
    unfold is_invariant_norm,
    repeat {split},
    { intro, apply nat.zero_le },
    { introv H,
      change gen_norm S h g with nat.find (h g) at H,
      have := nat.find_spec (h 1),
      
      simp [ball_zero_iff_id,H],
      
      admit },
    { admit },
    { admit },
    { admit },
    end

    #print nat.find_spec


example : (0:ℕ) < 6 := by dec_trivial



example (a b c d e f : nat) (h : a + d + c + f = c + b + d + e) : a + f = b + e :=
begin
apply add_right_cancel_iff.2,

simp [h,add_comm,add_assoc,add_left_cancel,add_right_cancel_iff,ac_refl],
end
example (p n : nat) : p+1+n = 3 :=
begin 
(have this :  p+1+n = (p+n)+1 := by simp) ▸ 
have numerology : p + 1 + n = (p + n) + 1, by simp,
rw numerology, clear numerology,
admit,
end

